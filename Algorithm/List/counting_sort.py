# 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇개 씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

L = [0, 4, 1, 3, 1, 2, 4, 1]
cnt = [0] * 10
D = {}

# 방법 1
for i in L :
    cnt[i] += 1
print(cnt)

# 방법 2
# for i in L :
#     D[i] = 0
# for i in L :
#     if L[i] in D.keys() :
#         D[i] += 1
# print(D)

# 오름차순 정렬하기
# 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
# A = [0, 4, 1, 3, 1, 2, 4, 1]  # 입력 배열
# B = []  # 정렬된 배열
# C = [0] * 8  # 카운트 배열
#
# for i in range(0, len(A)):
#     C[A[i]] += 1
#
# for i in range(1, len(C)):
#     C[i] += C[i - 1]
#
# for i in range(len(B) - 1, -1, -1):
#     C[A[i]] -= 1
#     B[C[A[i]]] = A[i]

# 순열 : 서로 다른것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
# nPr : 서로 다른 n개 중 r개를 택하는 순열은 아래와 같이 표현한다.
# nPr = n* (n-1) * (n-2) * ... * (n-r+1)
# nPn = n! 이라고 표기하면 Factorial이라 부른다
# n! = n * (n-1) * (n-2) * ... * 2 * 1



