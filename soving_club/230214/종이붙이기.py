'''
어린이 알고리즘 교실의 선생님은 경우의 수 놀이를 위해, 그림처럼 가로x세로 길이가 10x20, 20x20인 직사각형 종이를 잔뜩 준비했다.
그리고 교실 바닥에 20xN 크기의 직사각형을 테이프로 표시하고, 이 안에 준비한 종이를 빈틈없이 붙이는 방법을 찾아보려고 한다. N이 30인 경우 다음 그림처럼 종이를 붙일 수 있다.
10의 배수인 N이 주어졌을 때, 종이를 붙이는 모든 경우를 찾으려면 테이프로 만든 표시한 영역을 몇 개나 만들어야 되는지 계산하는 프로그램을 만드시오. 직사각형 종이가 모자라는 경우는 없다.

[입력]
첫 줄에 테스트 케이스 개수 T가 주어진다.  1≤T≤50
다음 줄부터 테스트 케이스 별로 N이 주어진다. 10≤N≤300, N은 10의 배수

[출력]
각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 답을 출력한다.

입력
3
30
50
70

출력
#1 5
#2 21
#3 85
'''


testCase = int(input())


# 재귀함수로 작성
def paper(N):
    if N % 10 == 0:
        if N == 10:
            return 1  # N이 10일때 붙이는 방법은 1개
        elif N == 20:
            return 3  # N이 20일때 붙이는 방법은 3개
        else:
            return paper(N - 10) + (2 * paper(N - 20))  # 같은 경우는 제외 해주기 때문에 2를 곱한다.
            # 최소범위의 값은 반환하고 최소범위만 남을때까지 반복


for tc in range(1, testCase + 1):
    N = int(input())
    result = paper(N)
    print(f'#{tc} {result}')

# memoization으로 작성

memo = [0] * 301
memo[10] = 1
memo[20] = 3


def paper2(N):
    # 기저조건
    if memo[N]:
        return memo[N]
    # 재귀호출 (점화식 코드)
    memo[N] = paper(N - 10) + (2 * paper(N - 20))
    return memo[N]


# DP방식 (함수 호출을 해서 재귀적으로 푸는 부분을 제거 -> 반복문)

dp = [0] * 301
# 기저조건
dp[10] = 1
dp[20] = 3

# 반복문을 사용해서, 작은 부분 -> 큰 부분으로 올라간다
for i in range(30, 301, 10):
    dp[i] = dp[i - 10] + 2 * dp[i - 20]

# 250에 대한 만들 수 있는 갯수들을  출력해라
print(dp[50])
