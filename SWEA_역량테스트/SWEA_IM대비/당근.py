'''
이싸피는 싸피 식당에 당근을 공급하고 있다. 이싸피의 당근은 맛도 있지만, 영양분이 풍부해 당근을 먹은 사람들이 알고리즘 문제를 더 잘 풀게 된다고 한다. 하지만 이싸피도 싸피 식당의 복잡한 포장 조건 때문에 늘 고생하고 있다.
싸피식당의 요구 조건은 다음과 같다.
N개의 당근을 주문하면 대, 중, 소 상자로 구분해 포장해야 한다.
같은 크기의 당근은 같은 상자에 들어있어야 한다.
비어 있는 상자가 있으면 안 된다.
한 상자에 N/2개(N이 홀수면 소수점 버림)를 초과하는 당근이 있어서도 안 된다.
앞의 조건을 만족하면서도, 각 상자에 든 당근의 개수 차이가 최소가 되도록 포장해야 한다. 그리고 이때의 개수 차이를 서류에 표시 한다.
새로운 주문이 들어와 이싸피는 N개의 당근을 밭에서 뽑아왔다. 대, 중, 소 상자를 각각 저울에 올려 포장해보는 대신, 뽑은 당근의 크기를 입력하면 모든 조건을 확인하는 프로그램을 만들어 이싸피가 쉽게 당근을 포장할 수 있게 도와보자.

예시1)
뽑아온 당근이 3개이고, 크기가 1 2 3이라면 다음과 같이 포장할 수 있다.
소 [ 1 ], 중 [ 2 ], 대 [ 3 ], 상자에 든 당근의 개수 차이는 0

예시2)
당근이 5개이고 크기가 1 1 1 2 3 이라면, 조건 (1)~(3)을 만족하는 포장은 다음과 같다.
           소[ 1 1 1 ], 중 [ 2 ], 대 [ 3 ], 당근의 개수 차이는 2
하지만 이 경우 5/2개(2개)를 초과하는 상자가 있으므로 조건(4)를 만족하지 못한다.

예시3)
당근이 8개 이고, 크기가 1 2 3 4 5 6 7 8인 경우이다. 우선 다음과 같이 포장할 수도 있다.
           소[ 1 2 3 4 ], 중[ 5 ], 대[ 6 7 8 ], 당근의 개수 차이는 3
하지만 다음과 같이 포장해야 조건(5)를 만족한다.
           소[ 1 2 3 ], 중[ 4 5 6 ], 대[ 7 8 ], 당근의 개수 차이는 1
또는 다음과 같은 경우도 조건(5)를 만족한다.
           소[ 1 2 ], 중[ 3 4 5 ], 대[ 6 7 8 ], 당근의 개수 차이는 1

[입력]
첫 줄에 총 수확 횟수 T가 주어진다.
각 수확에 대해, 첫 줄에 당근의 개수N, 다음 줄에 수확한 N개의 당근 크기 Ci가 빈칸으로 구분되어 주어진다. ( 3<=N<=1000, 1<=Ci<=30 )

[출력]
#과 1번부터인 수확번호에 이어, 포장 할 수 없는 경우 -1, 포장할 수 있으면 상자에 들어있는 당근의 개수 차이가 최소일 때의 차이값을 출력하라.

입력
3
3
1 2 3
5
1 1 1 2 3
8
1 2 3 4 5 6 7 8

출력
#1 0
#2 -1
#3 1
'''

T = int(input())
for tc in range(1, T + 1):
    N = int(input())
    C = list(map(int, input().split()))
    C.sort()
    MIN = N
    for i in range(N - 2):  # 소박스
        for j in range(i + 1, N - 1):  # 중박스
            if C[i] != C[i + 1] and C[j] != C[j + 1]:
                a = i + 1
                b = j - i
                c = N - 1 - j
                if a * b * c != 0 and a <= N // 2 and b <= N // 2 and c <= N // 2:
                    if MIN > max(a, b, c) - min(a, b, c):
                        MIN = max(a, b, c) - min(a, b, c)
    if MIN == N:
        MIN = -1
    print(f'#{tc}', MIN)
